### TerriblyTinyTales- Software Developer Application Challenge

##### TECHNOLOGY STACK USED
Backend - NodeJs/ExpressJs | UI/Frontend - Angular4, HTML, CSS, Bootstrap | Server - DigitalOcean Cloud

##### LIBRARIES/MIDDLEWARES USED
Lodash, Axios & Cors at the backend

##### COMPONENTS OF CODE
The solution consists of a frontend built on Angular4 that queries the requested operation from the backend via simple http POST request. The body of the request contains the number of words to be fetched from the server. The backend which caters to this service request is built on NodeJs over ExpressJs.

The request is received by the express router and the associated method is invoked. The request-inputs are validated and the source text data is pulled from the specified ttt link via the axios. The backend code uses ES7's features like async/await for code simplification & readability.

The source data is parsed using standard javascript methods alongwith lodash's functions to generate an array of object each containing the word and its frequency in key-value pairs sorted by the frequency in descending followed by the word in ascending. The requested number of words are extracted from the top of this array and rendered as a JSON response to the service.

##### THE PARSING ALGORITHM

The parsing algorith converts the source data into a sorted array of words each associated with its frequency of occurrence. Following are the steps taken for parsing the source data -

1. **Sanitizing & Splitting**

`var docArr = resp.data.replace(/\.*[\?\!\,\;\(\)\<\>\"\{\}\[\]\s\t\n\r]+/g,' ').replace(/[ ]*[\'][^a-zA-Z0-9]*/g, ' ').toLowerCase().split(" ");`
- Identification of sentence terminators like ?, !, comma etc. and converting them to space.
- Identification of paragraph terminators like \n, \t, \r etc. and converting them to space.
- Identification of special characters that prefix words like braces, quotes etc. and converting them to space.
- Converting text into lowercase for optimal matching and splitting the text into array of words by space.

2. **Generating Frequencies**

`docArr = _.countBy(_.filter(docArr,elem=>regex.test(elem.trim())), _.identity);`
- Frequency of each word is generated by the countBy method from the Lodash middleware.

3. **Generating Sorted Object**

`docArr = _.orderBy(_.map(_(docArr).toPairs().value(),(n)=>{return {'word':n[0],'frequency':n[1]}}), ['frequency', 'word'],['desc','asc']);`
- An array of objects, each consisting of the word and its frequency in separate keys is then created and sorted first by the frequency and then by the word. This is achieved by the map & orderBy methods of the Lodash middleware.
